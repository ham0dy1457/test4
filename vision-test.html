<!doctype html>
<html lang="en" data-page="vision-test">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Vision Test • VisionCare</title>
    <meta name="description" content="Vision test with camera distance check and E orientation.">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="site-header">
        <div class="container header-inner">
            <button class="back-btn" id="back-btn" aria-label="Go back">←</button>
            <a class="logo" href="index.html">VisionCare</a>
        </div>
    </header>

    <div class="vt-camera" aria-hidden="true">
		<video id="vt-video" autoplay playsinline muted></video>
		<canvas id="vt-overlay" style="position:absolute;inset:0;width:100%;height:100%;pointer-events:none;"></canvas>
    </div>

    <main class="section">
        <div class="container">
            <h1>Vision Test</h1>

            <div class="vt-card">
                <div class="vt-status">
                    <span id="distance-status">Checking distance…</span>
                    <span id="ready-badge" class="badge">Adjust</span>
					<span id="attention-status" class="badge" style="margin-left:8px;">Attention: --%</span>
                    <button id="toggle-camera" class="btn">Toggle Camera</button>
                </div>

                <div class="vt-warning" id="vt-warning" role="status" aria-live="polite"></div>

                <div class="vt-stage" id="vt-stage">
                    <div class="dual-symbols">
                        <div class="symbol-container left-eye">
                            <div id="vt-letter-left" class="vt-letter" aria-hidden="true">C</div>
                            <div class="eye-label">Left Eye</div>
                        </div>
                        <div class="symbol-container right-eye">
                            <div id="vt-letter-right" class="vt-letter" aria-hidden="true">C</div>
                            <div class="eye-label">Right Eye</div>
                        </div>
                    </div>
                    <div class="vt-controls">
                        <button class="btn" data-dir="up">↑</button>
                        <button class="btn" data-dir="down">↓</button>
                        <button class="btn" data-dir="left">←</button>
                        <button class="btn" data-dir="right">→</button>
                    </div>
                </div>

                <div class="vt-actions">
                    <button id="vt-start" class="btn primary" disabled>Start Test</button>
                    <button id="vt-retry" class="btn" hidden>Retake</button>
                </div>

                <div class="vt-result" id="vt-result" hidden>
                    <div class="result-summary" id="result-summary"></div>
                    <div class="results-table-container" id="results-table-container" hidden>
                        <h3>Vision Test Report</h3>
                        <div class="test-info">
                            <span id="test-date"></span>
                            <span id="test-time"></span>
                        </div>
                        <table class="results-table">
                            <thead>
                                <tr>
                                    <th>Parameter</th>
                                    <th>Right Eye</th>
                                    <th>Left Eye</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Distance (m)</td>
                                    <td id="right-distance">-</td>
                                    <td id="left-distance">-</td>
                                </tr>
                                <tr>
                                    <td>Lighting Quality (%)</td>
                                    <td id="right-lighting">-</td>
                                    <td id="left-lighting">-</td>
                                </tr>
                                <tr>
                                    <td>Visual Acuity (LogMAR)</td>
                                    <td id="right-logmar">-</td>
                                    <td id="left-logmar">-</td>
                                </tr>
                                <tr>
                                    <td>Contrast Sensitivity (%)</td>
                                    <td id="right-contrast">-</td>
                                    <td id="left-contrast">-</td>
                                </tr>
                                <tr>
                                    <td>Eye Tracking Reliability (%)</td>
                                    <td id="right-tracking">-</td>
                                    <td id="left-tracking">-</td>
                                </tr>
                                <tr class="overall-result">
                                    <td><strong>Overall Result</strong></td>
                                    <td id="right-overall">-</td>
                                    <td id="left-overall">-</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <p>© <span id="year"></span> VisionCare</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/webrtc-adapter/9.0.1/adapter.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.5/dist/face-landmarks-detection.min.js" crossorigin="anonymous"></script>
	<!-- Firebase (compat) for simple CDN usage -->
	<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
	<script>
		// TODO: Replace with your Firebase project config values
		window.FIREBASE_CONFIG = {
			apiKey: "",
			authDomain: "",
			projectId: "",
			storageBucket: "",
			messagingSenderId: "",
			appId: ""
		};
	</script>
	<!-- MediaPipe FaceMesh dependencies for improved distance & attention -->
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="js/app.js" defer></script>
	<script src="js/db.js" defer></script>
    <script src="js/vision.js" defer></script>
	<script>
		// Enhanced camera distance and eye attention using MediaPipe FaceMesh
		(function () {
			const INTER_EYE_DISTANCE_CM = 5.5; // average interpupillary distance
			const FOCAL_LENGTH = 800; // calibrated focal length constant

			// MediaPipe landmark indices
			const LEFT_EYE_INDICES = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];
			const RIGHT_EYE_INDICES = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];
			const LEFT_EYE_CENTER = 468;
			const RIGHT_EYE_CENTER = 473;

			const video = document.getElementById('vt-video');
			const canvas = document.getElementById('vt-overlay');
			const ctx = canvas.getContext('2d');
			const distanceEl = document.getElementById('distance-status');
			const attentionEl = document.getElementById('attention-status');
			const readyBadge = document.getElementById('ready-badge');
			const warningEl = document.getElementById('vt-warning');

			let faceMesh = null;
			let running = false;
			let cameraStartTime = null;
			let eyeContactTime = 0;
			let lastEyeContactTime = null;

			function resizeCanvasToVideo() {
				if (!video.videoWidth || !video.videoHeight) return;
				const rect = video.getBoundingClientRect();
				canvas.width = video.videoWidth;
				canvas.height = video.videoHeight;
				// Ensure canvas visually overlays video size
				canvas.style.width = rect.width + 'px';
				canvas.style.height = rect.height + 'px';
			}

			function updateReady(isReady) {
				if (!readyBadge) return;
				readyBadge.textContent = isReady ? 'Ready' : 'Adjust';
				readyBadge.classList.toggle('ready', isReady);
				readyBadge.classList.toggle('adjust', !isReady);
			}

			function updateDistance(distanceCm) {
				if (!Number.isFinite(distanceCm)) {
					distanceEl.textContent = 'Distance: No face detected';
					updateReady(false);
					return;
				}
				const meters = distanceCm / 100;
				distanceEl.textContent = `Distance: ${meters.toFixed(2)} m`;
				const inRange = meters >= 0.30 && meters <= 0.50;
				if (warningEl) warningEl.textContent = inRange ? '' : 'Please move farther or closer to the screen to start the test.';
				updateReady(inRange);
			}

			function getBoundingBox(landmarks) {
				const xs = landmarks.map(l => l.x * (canvas.width || 640));
				const ys = landmarks.map(l => l.y * (canvas.height || 480));
				const minX = Math.min(...xs), maxX = Math.max(...xs);
				const minY = Math.min(...ys), maxY = Math.max(...ys);
				return { minX, maxX, minY, maxY, centerX: (minX + maxX) / 2, centerY: (minY + maxY) / 2 };
			}

			function isIrisCentered(iris, eyeBounds) {
				const irisX = iris.x * (canvas.width || 640);
				const irisY = iris.y * (canvas.height || 480);
				const thresholdX = (eyeBounds.maxX - eyeBounds.minX) * 0.3;
				const thresholdY = (eyeBounds.maxY - eyeBounds.minY) * 0.3;
				return Math.abs(irisX - eyeBounds.centerX) < thresholdX && Math.abs(irisY - eyeBounds.centerY) < thresholdY;
			}

			function updateAttention(hasContact) {
				const now = Date.now();
				if (cameraStartTime == null) cameraStartTime = now;
				if (hasContact) {
					if (lastEyeContactTime == null) lastEyeContactTime = now;
				} else if (lastEyeContactTime != null) {
					eyeContactTime += now - lastEyeContactTime;
					lastEyeContactTime = null;
				}
				const totalTime = now - cameraStartTime;
				if (totalTime > 100) {
					let currentContact = eyeContactTime;
					if (hasContact && lastEyeContactTime != null) currentContact += now - lastEyeContactTime;
					const pct = Math.min(100, (currentContact / totalTime) * 100);
					if (attentionEl) attentionEl.textContent = `Attention: ${pct.toFixed(1)}%`;
				}
			}

			function onResults(results) {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
					updateDistance(NaN);
					updateAttention(false);
					return;
				}
				const lm = results.multiFaceLandmarks[0];
				// distance via iris centers
				const left = lm[LEFT_EYE_CENTER];
				const right = lm[RIGHT_EYE_CENTER];
				if (left && right) {
					const lx = left.x * (canvas.width || 640);
					const ly = left.y * (canvas.height || 480);
					const rx = right.x * (canvas.width || 640);
					const ry = right.y * (canvas.height || 480);
					const pixelDist = Math.hypot(rx - lx, ry - ly);
					if (pixelDist > 0) {
						const cm = (INTER_EYE_DISTANCE_CM * FOCAL_LENGTH) / pixelDist;
						updateDistance(cm);
					}
				}
				// attention via iris within eye bounds
				const leftEyeLandmarks = LEFT_EYE_INDICES.map(i => lm[i]).filter(Boolean);
				const rightEyeLandmarks = RIGHT_EYE_INDICES.map(i => lm[i]).filter(Boolean);
				let hasContact = false;
				if (lm[LEFT_EYE_CENTER] && lm[RIGHT_EYE_CENTER] && leftEyeLandmarks.length && rightEyeLandmarks.length) {
					const lb = getBoundingBox(leftEyeLandmarks);
					const rb = getBoundingBox(rightEyeLandmarks);
					const leftCentered = isIrisCentered(lm[LEFT_EYE_CENTER], lb);
					const rightCentered = isIrisCentered(lm[RIGHT_EYE_CENTER], rb);
					hasContact = leftCentered && rightCentered;
				}
				updateAttention(hasContact);

				// optional draw eyes
				try {
					if (typeof drawConnections !== 'undefined' && typeof FACEMESH_TESSELATION !== 'undefined') {
						drawConnections(ctx, lm, FACEMESH_TESSELATION, { color: '#00FF0020', lineWidth: 1 });
					}
				} catch (_) {}
			}

			async function ensureFaceMesh() {
				if (faceMesh) return faceMesh;
				if (typeof FaceMesh === 'undefined') return null;
				faceMesh = new FaceMesh({
					locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
				});
				faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
				faceMesh.onResults(onResults);
				return faceMesh;
			}

			async function loop() {
				if (!running) return;
				try {
					if (faceMesh && video.readyState >= 2) {
						await faceMesh.send({ image: video });
					}
				} catch (_) {}
				requestAnimationFrame(loop);
			}

			function start() {
				if (running) return;
				running = true;
				cameraStartTime = Date.now();
				resizeCanvasToVideo();
				loop();
			}

			window.addEventListener('load', async () => {
				// Wait for video to have dimensions from existing camera stream (vision.js handles getUserMedia)
				if (video) {
					if (video.readyState < 2) {
						video.addEventListener('loadedmetadata', resizeCanvasToVideo, { once: true });
					} else {
						resizeCanvasToVideo();
					}
				}
				await ensureFaceMesh();
				start();
			});
		})();
	</script>
</body>
</html>

